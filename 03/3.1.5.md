### 3.1.5 v-for

我们可以使用 v-for 指令基于源数据重复渲染元素。代码示例如下：

    <body id="example">
        <ul id="demo">
            <li v-for="(item, index) in items">
                {{ index }} - {{parentMessage}} {{item.msg}}
            </li>
        </ul>
    </body>
    <script>
        var demo = new Vue({
            el: '#demo',
            data: {
                parentMessage: 'DD',
                items: [
                    {msg: '顺风车'},
                    {msg: '专车'}
                ]
            }
        });
    </script>

v-for 需要特殊的别名，形式为 "item in items" (items 是数据数组，item 是当前数组元素的别名)。
v-for 在开始时对传入的表达式做了语法分析，不是 "item in/of items" 的形式，将给出警告信息。
Vue.js 1.0.17 及以后版本支持 of 分隔符，更接近 JavaScript 遍历器语法，用法如下：

    <div v-for="item of items"></div>

使用 v-for 将得到一个特殊的作用域，类似于 AngularJS 的隔离作用域，我们需要明确指定 props 属性传递数据，
否则在组件内将获取不到数据。对于组件内的 <p> 标签，我们可以使用 <slot>:

    <my-item v-for="item in items" :item="item" :index="$index">
        <p>{{item.text}}</p>
    </my-item>

当数组数据出现变动时如何检测呢？Vue.js 包装了被观察数组的变异方法，它们能触发视图更新。被包装的方法有：

    - push()
    - pop()
    - shift()
    - unshift()
    - splice()
    - sort()
    - reverse()

Vue.js 还增加了两个方法来观测变化：$set、$remove。

我们应该尽量避免直接设置数据绑定的数组元素，因为这些变化不会被 Vue.js 检测到，因而也不会更新视图渲染。这时，我们可以使用 $set 方法：

    // same as `demo.items[0]` = ... ` but triggers view update`
    demo.items.$set(0, { childMsg: 'Changed!'});

$remove 是 splice 的语法糖，用于从目标数组中查找并删除元素。因此不必这样：

    var index = this.items.indexOf(item);
    if(index !== -1){
        this.items.splice(index, 1);
    }

只用这样：

    demo.items.$remove(item);

另外，也可以使用 filter、concat、slice 方法，返回的数组将是一个不同的实例。